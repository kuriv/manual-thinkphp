{"./":{"url":"./","title":"ThinkPHP","keywords":"","body":"ThinkPHP ThinkPHP 是一套快速、简单的轻量级 PHP 开发框架。 "},"docs/路由.html":{"url":"docs/路由.html","title":"路由","keywords":"","body":"路由 路由基础 路由定义 变量规则 路由地址 闭包支持 路由参数 路由缓存 跨域请求 注解路由 路由分组 MISS 路由 资源路由 快捷路由 路由别名 路由绑定 域名路由 URI 生成 "},"docs/路由/路由基础.html":{"url":"docs/路由/路由基础.html","title":"路由基础","keywords":"","body":"路由基础 强制路由 延迟解析 路由规则合并解析 路由缓存 强制路由 如果一个 URI 没有定义路由，则采用默认的 PATH_INFO 模式访问。 http://localhost/index.php/module/controller/action/param/value/... 可以在配置文件中设置来开启强制使用路由，这种方式必须严格给每一个访问地址定义路由规则。 'url_route_must' => true, 延迟解析 通过路由分组或者域名路由来定义路由才能发挥延迟解析的优势。一旦开启路由的延迟解析，只有实际匹配到该域名或者分组后才会进行路由规则的注册，避免不必要的注册和解析开销。 'url_lazy_route' => true, 路由规则合并解析 可以在配置文件中设置开启全局合并规则。 'route_rule_merge' => true, 或者在路由定义的时候对某个分组单独开启合并规则解析。这样该分组下的所有路由规则无论定义多少个都只需要匹配检查一次即可。 mergeRuleRegex(); 路由缓存 路由缓存对于路由规则较多的应用可以大幅提升路由性能。如果路由定义中，有某个路由规则的路由地址使用了闭包的方式，那么路由缓存将会失效。 'route_check_cache' => true, "},"docs/路由/路由定义.html":{"url":"docs/路由/路由定义.html","title":"路由定义","keywords":"","body":"路由定义 注册路由规则 规则表达式 可选定义 完全匹配 额外参数 路由标识 注册路由规则 最基础的路由定义方法是使用下面的方法。 上面的方法会自动路由到下面的地址，并且原来的 PATH_INFO 访问模式会自动失效。 http://localhost/index/index/index/name/world 可以指定请求类型，不指定的话默认为任何请求类型有效。 如果要定义多种请求类型的路由规则，可以使用下面的方法。 不过通常情况下还是使用对应请求类型的快捷方法。注册多个路由规则后，系统会依次遍历注册过的满足请求类型的路由规则，一旦匹配到正确的路由规则后则开始执行最终的调度方法，后续规则就不再检测。 规则表达式 规则表达式通常包含静态地址和动态地址，或者两种地址的结合。 可选定义 也支持对路由参数的可选定义。可选参数只能放到路由规则的最后，如果在中间使用了可选参数的话，后面的变量都会变成可选参数。 完全匹配 规则匹配检测的时候默认只是对 URI 从头开始匹配，只要 URI 地址包含了定义的路由规则就会匹配成功，如果希望 URI 进行完全匹配，可以使用下面的方法。 当使用上面的方法定义路由后，下面的地址会匹配成功。 http://localhost/hello/world 而下面的地址则不会匹配成功。 http://localhost/hello/world/think 如果需要全局进行 URI 完全匹配，可以在配置文件中设置。 'route_complete_match' => true, 额外参数 在路由跳转的时候支持额外传入参数对，额外参数指的是不在 URI 里面的参数，隐式传入需要的操作中，有时候能够起到一定的安全防护作用。 路由标识 如果你需要快速的根据路由生成 URI 地址，可以在定义路由的时候指定生成标识，但要确保唯一。 name('hello'); 这样生成路由地址的时候就可以使用下面的方法。 'world' ]); 如果不定义路由标识的话，可以使用下面的方式生成。 'world' ]); "},"docs/路由/变量规则.html":{"url":"docs/路由/变量规则.html","title":"变量规则","keywords":"","body":"变量规则 变量规则 局部变量规则 全局变量规则 组合变量规则 动态路由 变量规则 系统默认的变量规则设置是 \\w+ ，只会匹配字母、数字和下划线字符，并不会匹配特殊符号和中文，需要定义变量规则或者调整默认变量规则。 'default_route_pattern' => '[\\w\\-]+' 局部变量规则 定义局部变量规则，仅在当前路由有效。 pattern([ 'name' => '\\w+' ]); 全局变量规则 定义全局变量规则，全部路由有效。 '\\w+' ]); Route::get('hello/:name', 'index/index/index'); Route::get('think/:name', 'index/index/think'); 组合变量规则 如果你的路由规则比较特殊，可以在路由定义的时候使用组合变量。组合变量的优势是路由规则中没有固定的分隔符，可以随意组合需要的变量规则和分割符。 -', 'index/index/index')->pattern([ 'name' => '\\w+', 'id' => '\\d+' ]); 使用组合变量的情况下如果需要使用可选变量，则可以使用下面的方法。 -', 'index/index/index')->pattern([ 'name' => '\\w+', 'id' => '\\d+' ]); 动态路由 可以把路由规则中的变量传入路由地址中，就可以实现一个动态路由。 "},"docs/路由/路由地址.html":{"url":"docs/路由/路由地址.html","title":"路由地址","keywords":"","body":"路由地址 路由到模块/控制器/操作 路由到操作方法 路由到类的方法 路由到重定向地址 路由到模板 路由到模块/控制器/操作 解析规则是从操作开始解析，然后解析控制器，最后解析模块。 类文件定义如下： 路由地址中支持多级控制器，可以使用下面的方式进行设置。 类文件定义如下： 路由到操作方法 路由到操作方法看起来似乎和上面的方法是一样的，本质的区别是直接执行某个控制器类的方法，而不需要去解析操作，控制器模块，同时也不会去初始化模块，因此不会调用模块的初始化方法。通常这种方式下面，由于没有定义当前模块名，控制器名和方法名，从而导致视图的默认模板规则失效，所以如果使用了视图模板渲染，则必须传入明确的参数而不是留空。 类文件定义如下： 路由到类的方法 路由到类的方法更进一步，可以支持执行任何类的方法，而不仅仅是执行控制器的操作方法。 也支持执行某个静态方法。 支持传入额外的参数作为方法的参数调用，用于参数绑定。 路由到重定向地址 可以使用下面的方法注册一个重定向路由。 路由重定向默认使用 301 状态码，可以使用可选的第三个参数来自定义这个状态码。 路由到模板 路由支持直接渲染模板输出。 如果需要增加额外的模板变量，可以使用下面的方法。 'ThinkPHP' ]); "},"docs/路由/闭包支持.html":{"url":"docs/路由/闭包支持.html","title":"闭包支持","keywords":"","body":"闭包支持 闭包定义 依赖注入 指定响应对象 闭包定义 可以使用闭包的方式定义一些特殊需求的路由，而不需要执行控制器的操作方法。 闭包定义的时候支持参数传递，规则路由中定义的动态变量的名称就是闭包函数中的参数名称，不分次序。 依赖注入 可以在闭包中使用依赖注入。 method(); }); 指定响应对象 更多的情况是在路由闭包中指定响应对象输出。 data($name)->code(200)->contentType('text/plain'); }); 上面的情况可以直接写成： data($name)->code(200)->contentType('text/plain'); }); 还可以对请求设置 404 访问： code(404); }); "},"docs/路由/路由参数.html":{"url":"docs/路由/路由参数.html","title":"路由参数","keywords":"","body":"路由参数 "},"docs/路由/路由缓存.html":{"url":"docs/路由/路由缓存.html","title":"路由缓存","keywords":"","body":"路由缓存 "},"docs/路由/跨域请求.html":{"url":"docs/路由/跨域请求.html","title":"跨域请求","keywords":"","body":"跨域请求 "},"docs/路由/注解路由.html":{"url":"docs/路由/注解路由.html","title":"注解路由","keywords":"","body":"注解路由 "},"docs/路由/路由分组.html":{"url":"docs/路由/路由分组.html","title":"路由分组","keywords":"","body":"路由分组 "},"docs/路由/MISS 路由.html":{"url":"docs/路由/MISS 路由.html","title":"MISS 路由","keywords":"","body":"MISS 路由 "},"docs/路由/资源路由.html":{"url":"docs/路由/资源路由.html","title":"资源路由","keywords":"","body":"资源路由 "},"docs/路由/快捷路由.html":{"url":"docs/路由/快捷路由.html","title":"快捷路由","keywords":"","body":"快捷路由 "},"docs/路由/路由别名.html":{"url":"docs/路由/路由别名.html","title":"路由别名","keywords":"","body":"路由别名 "},"docs/路由/路由绑定.html":{"url":"docs/路由/路由绑定.html","title":"路由绑定","keywords":"","body":"路由绑定 "},"docs/路由/域名路由.html":{"url":"docs/路由/域名路由.html","title":"域名路由","keywords":"","body":"域名路由 "},"docs/路由/URI 生成.html":{"url":"docs/路由/URI 生成.html","title":"URI 生成","keywords":"","body":"URI 生成 "},"docs/控制器.html":{"url":"docs/控制器.html","title":"控制器","keywords":"","body":"控制器 "},"docs/控制器/控制器定义.html":{"url":"docs/控制器/控制器定义.html","title":"控制器定义","keywords":"","body":"控制器定义 "},"docs/控制器/前置操作.html":{"url":"docs/控制器/前置操作.html","title":"前置操作","keywords":"","body":"前置操作 "},"docs/控制器/跳转和重定向.html":{"url":"docs/控制器/跳转和重定向.html","title":"跳转和重定向","keywords":"","body":"跳转和重定向 "},"docs/控制器/空操作和空控制器.html":{"url":"docs/控制器/空操作和空控制器.html","title":"空操作和空控制器","keywords":"","body":"空操作和空控制器 "},"docs/控制器/分层控制器.html":{"url":"docs/控制器/分层控制器.html","title":"分层控制器","keywords":"","body":"分层控制器 "},"docs/控制器/资源控制器.html":{"url":"docs/控制器/资源控制器.html","title":"资源控制器","keywords":"","body":"资源控制器 "},"docs/控制器/控制器中间件.html":{"url":"docs/控制器/控制器中间件.html","title":"控制器中间件","keywords":"","body":"控制器中间件 "},"docs/请求.html":{"url":"docs/请求.html","title":"请求","keywords":"","body":"请求 "},"docs/请求/请求对象.html":{"url":"docs/请求/请求对象.html","title":"请求对象","keywords":"","body":"请求对象 "},"docs/请求/请求信息.html":{"url":"docs/请求/请求信息.html","title":"请求信息","keywords":"","body":"请求信息 "},"docs/请求/输入变量.html":{"url":"docs/请求/输入变量.html","title":"输入变量","keywords":"","body":"输入变量 "},"docs/请求/请求类型.html":{"url":"docs/请求/请求类型.html","title":"请求类型","keywords":"","body":"请求类型 "},"docs/请求/HTTP 头信息.html":{"url":"docs/请求/HTTP 头信息.html","title":"HTTP 头信息","keywords":"","body":"HTTP 头信息 "},"docs/请求/伪静态.html":{"url":"docs/请求/伪静态.html","title":"伪静态","keywords":"","body":"伪静态 "},"docs/请求/参数绑定.html":{"url":"docs/请求/参数绑定.html","title":"参数绑定","keywords":"","body":"参数绑定 "},"docs/请求/请求缓存.html":{"url":"docs/请求/请求缓存.html","title":"请求缓存","keywords":"","body":"请求缓存 "},"docs/响应.html":{"url":"docs/响应.html","title":"响应","keywords":"","body":"响应 "},"docs/响应/响应输出.html":{"url":"docs/响应/响应输出.html","title":"响应输出","keywords":"","body":"响应输出 "},"docs/响应/响应参数.html":{"url":"docs/响应/响应参数.html","title":"响应参数","keywords":"","body":"响应参数 "},"docs/响应/重定向.html":{"url":"docs/响应/重定向.html","title":"重定向","keywords":"","body":"重定向 "},"docs/响应/文件下载.html":{"url":"docs/响应/文件下载.html","title":"文件下载","keywords":"","body":"文件下载 "}}